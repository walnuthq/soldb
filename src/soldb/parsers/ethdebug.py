"""
ETHDebug Parser for EVM Debugging

Parses ethdebug format debug information generated by solc compiler (>= 0.8.29).
Also provides multi-contract support for cross-contract debugging.
"""

import json
import os
from typing import Dict, List, Optional, Tuple, Any, Union
from dataclasses import dataclass, field
from pathlib import Path

from eth_utils import to_checksum_address


# =============================================================================
# Data Classes
# =============================================================================

@dataclass
class SourceLocation:
    """Represents a source code location."""
    source_id: int
    offset: int
    length: int
    
    def __repr__(self):
        return f"Source({self.source_id}:{self.offset}+{self.length})"


@dataclass
class Instruction:
    """Represents a single EVM instruction with debug info."""
    offset: int  # Bytecode offset
    operation: Dict[str, Any]  # mnemonic and arguments
    context: Optional[Dict[str, Any]] = None  # Source mapping context
    
    @property
    def mnemonic(self) -> str:
        return self.operation.get('mnemonic', '')
    
    @property
    def arguments(self) -> List[str]:
        return self.operation.get('arguments', [])
    
    @property
    def source_location(self) -> Optional[SourceLocation]:
        if not self.context or 'code' not in self.context:
            return None
        
        code_info = self.context['code']
        if 'source' in code_info and 'range' in code_info:
            return SourceLocation(
                source_id=code_info['source']['id'],
                offset=code_info['range']['offset'],
                length=code_info['range']['length']
            )
        return None


@dataclass
class VariableLocation:
    """Represents a variable's location in stack/memory/storage."""
    name: str
    type: str
    location_type: str  # "stack", "memory", "storage"
    offset: int
    pc_range: Tuple[int, int]  # (start_pc, end_pc)
    
    def is_active_at_pc(self, pc: int) -> bool:
        """Check if this variable is active at the given PC."""
        return self.pc_range[0] <= pc <= self.pc_range[1]


@dataclass
class ETHDebugInfo:
    """Container for ethdebug debugging information."""
    compilation: Dict[str, Any]
    contract_name: str
    environment: str  # 'create' or 'runtime'
    instructions: List[Instruction]
    sources: Dict[int, str]  # source_id -> file path
    variable_locations: Dict[int, List[VariableLocation]] = field(default_factory=dict)  # PC -> variables
    
    def get_instruction_at_pc(self, pc: int) -> Optional[Instruction]:
        """Get instruction at specific program counter."""
        for instruction in self.instructions:
            if instruction.offset == pc:
                return instruction
        return None
    
    def get_source_info(self, pc: int) -> Optional[Tuple[str, int, int]]:
        """Get source file and location for PC."""
        instruction = self.get_instruction_at_pc(pc)
        if not instruction or not instruction.source_location:
            return None
        
        source_loc = instruction.source_location
        source_file = self.sources.get(source_loc.source_id)
        if not source_file:
            return None
        
        return (source_file, source_loc.offset, source_loc.length)
    
    def get_variables_at_pc(self, pc: int) -> List[VariableLocation]:
        """Get all variables active at the given PC."""
        # First check if we have exact PC match
        if pc in self.variable_locations:
            return self.variable_locations[pc]
        
        # Otherwise, find all variables whose range includes this PC
        active_vars = []
        for _, var_list in self.variable_locations.items():
            for var in var_list:
                if var.is_active_at_pc(pc):
                    active_vars.append(var)
        
        return active_vars


# =============================================================================
# ETHDebug Directory Specification
# =============================================================================

@dataclass
class ETHDebugSpec:
    """Represents a parsed ethdebug directory specification."""
    address: Optional[str] = None
    name: Optional[str] = None
    path: str = ""
    
    def __post_init__(self):
        """Validate the parsed specification."""
        if self.address and not self.address.startswith('0x'):
            raise ValueError(f"Address must start with '0x': {self.address}")
        
        if not self.path:
            raise ValueError("Path cannot be empty")
        
        if not os.path.exists(self.path):
            raise ValueError(f"Path does not exist: {self.path}")


class ETHDebugDirParser:
    """Parser for ethdebug_dir paths."""
    
    @staticmethod
    def parse_single_contract(ethdebug_spec: str) -> ETHDebugSpec:
        """
        Parse single contract ethdebug specification.
        Expected format: 'address:name:path'
        """
        if ':' not in ethdebug_spec or not ethdebug_spec.startswith('0x'):
            raise ValueError(f"Must use format 'address:name:path' (got: {ethdebug_spec})")
        
        parts = ethdebug_spec.split(':', 2)
        if len(parts) != 3:
            raise ValueError(f"Must use format 'address:name:path' (got: {ethdebug_spec})")
        
        address, name, path = parts
        path = os.path.normpath(path)
        
        return ETHDebugSpec(address=address, name=name, path=path)
    
    @staticmethod
    def parse_multi_contract(ethdebug_spec: str) -> ETHDebugSpec:
        """
        Parse multi-contract ethdebug specification.
        Expected format: 'address:path' or just 'path'
        """
        if ':' in ethdebug_spec and ethdebug_spec.startswith('0x'):
            parts = ethdebug_spec.split(':', 1)
            if len(parts) != 2:
                raise ValueError(f"Must use format 'address:path' (got: {ethdebug_spec})")
            
            address, path = parts
            path = os.path.normpath(path)
            
            return ETHDebugSpec(address=address, name=None, path=path)
        else:
            path = os.path.normpath(ethdebug_spec)
            return ETHDebugSpec(address=None, name=None, path=path)
    
    @staticmethod
    def parse_ethdebug_dirs(ethdebug_dirs: List[str]) -> List[ETHDebugSpec]:
        """Parse a list of ethdebug directory specifications."""
        if not ethdebug_dirs:
            return []
        
        specs = []
        for ethdebug_spec in ethdebug_dirs:
            try:
                spec = ETHDebugDirParser.parse_single_contract(ethdebug_spec)
                specs.append(spec)
            except ValueError as e:
                raise ValueError(f"Invalid ethdebug specification '{ethdebug_spec}': {e}")
        
        return specs
    
    @staticmethod
    def find_abi_file(spec: ETHDebugSpec, contract_name: Optional[str] = None) -> Optional[str]:
        """Find ABI file for the given specification."""
        ethdebug_dir = Path(spec.path)
        
        if contract_name:
            abi_path = ethdebug_dir / f"{contract_name}.abi"
            if abi_path.exists():
                return str(abi_path)
        
        for abi_file in ethdebug_dir.glob("*.abi"):
            return str(abi_file)
        
        return None


# =============================================================================
# Source File Loader (Singleton)
# =============================================================================

class SourceFileLoader:
    """Centralized source file loader with global cache."""
    
    _instance = None
    _source_cache: Dict[str, List[str]] = {}
    _warning_shown: set = set()
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    def load_source_file(self, source_path: str, debug_dir: Optional[str] = None) -> List[str]:
        """Load and cache source file lines globally."""
        if source_path not in self._source_cache:
            result = self._find_and_load_source_file(source_path, debug_dir)
            self._source_cache[source_path] = result
            
            if not result and source_path not in self._warning_shown:
                self._warning_shown.add(source_path)
                # Import here to avoid circular import
                from soldb.utils.colors import warning
                print(warning(f"Warning: Source file not found: {source_path}"))
        
        return self._source_cache[source_path]
    
    def _find_and_load_source_file(self, source_path: str, debug_dir: Optional[str] = None) -> List[str]:
        """Find and load a source file using simplified pattern."""
        result = self._try_load_file(Path(source_path))
        if result:
            return result
        
        root_project_dir = self._find_root_project_directory()
        if root_project_dir:
            full_source_path = root_project_dir / source_path
            result = self._try_load_file(full_source_path)
            if result:
                return result
        
        if debug_dir:
            current_dir = Path(debug_dir)
            filename = os.path.basename(source_path)
            
            for _ in range(2):
                test_path = current_dir / source_path
                result = self._try_load_file(test_path)
                if result:
                    return result
                
                test_path = current_dir / filename
                result = self._try_load_file(test_path)
                if result:
                    return result
                
                parent = current_dir.parent
                if parent == current_dir:
                    break
                current_dir = parent
        
        return []
    
    def _find_root_project_directory(self) -> Optional[Path]:
        """Find the root project directory."""
        current_dir = Path.cwd()
        out_dir = current_dir / "out"
        
        if out_dir.exists() and out_dir.is_dir():
            return current_dir
        
        return None
    
    def _try_load_file(self, file_path: Path) -> Optional[List[str]]:
        """Try to load a file and return its contents or None if failed."""
        if file_path.exists() and file_path.is_file():
            try:
                with open(file_path) as f:
                    return f.readlines()
            except (IsADirectoryError, PermissionError, UnicodeDecodeError):
                pass
        return None


# Global source loader instance
source_loader = SourceFileLoader()


# =============================================================================
# ETHDebug Parser
# =============================================================================

class ETHDebugParser:
    """Parser for ethdebug format debug information."""
    
    def __init__(self):
        self.debug_info: Optional[ETHDebugInfo] = None
        self.source_cache: Dict[str, List[str]] = {}
        self.debug_dir: Optional[Path] = None
    
    def load_ethdebug_files(self, debug_dir: Union[str, Path], contract_name: Optional[str] = None) -> ETHDebugInfo:
        """Load ethdebug files from a directory."""
        debug_dir = Path(debug_dir)
        self.debug_dir = debug_dir
        
        # Load compilation info
        compilation_file = debug_dir / "ethdebug.json"
        if not compilation_file.exists():
            compiler_info = self._get_compiler_info(str(debug_dir))
            error_msg = f"ethdebug.json not found in {debug_dir}"
            if compiler_info:
                error_msg += f" (compiler: {compiler_info})"
            raise FileNotFoundError(error_msg)
        
        with open(compilation_file) as f:
            compilation_data = json.load(f)
        
        # Build source mapping
        sources = {}
        for source in compilation_data['compilation']['sources']:
            sources[source['id']] = source['path']
        
        debug_file = None
        environment = None

        if contract_name:
            target_source_id = None
            for source_id, source_path in sources.items():
                if contract_name.lower() in source_path.lower():
                    target_source_id = source_id
                    break
            
            if target_source_id is None:
                for source_id, source_path in sources.items():
                    filename = os.path.splitext(os.path.basename(source_path))[0]
                    if filename.lower() == contract_name.lower():
                        target_source_id = source_id
                        break
            
            if target_source_id is None:
                raise FileNotFoundError(f"No source found containing contract name '{contract_name}' in sources: {list(sources.values())}")
            
            target_source_path = sources[target_source_id]
            contract_name_from_source = os.path.splitext(os.path.basename(target_source_path))[0]
            
            runtime_file = debug_dir / f"{contract_name_from_source}_ethdebug-runtime.json"
            create_file = debug_dir / f"{contract_name_from_source}_ethdebug.json"
            if runtime_file.exists():
                debug_file = runtime_file
                environment = 'runtime'
            elif create_file.exists():
                debug_file = create_file
                environment = 'create'
            else:
                compiler_info = self._get_compiler_info(str(debug_dir))
                error_msg = f"No ethdebug file found for contract {contract_name_from_source} in {debug_dir}"
                if compiler_info:
                    error_msg += f" (compiler: {compiler_info})"
                raise FileNotFoundError(error_msg)
        else:
            if sources:
                first_source_path = next(iter(sources.values()))
                contract_name_guess = os.path.splitext(os.path.basename(first_source_path))[0]
                runtime_file = debug_dir / f"{contract_name_guess}_ethdebug-runtime.json"
                create_file = debug_dir / f"{contract_name_guess}_ethdebug.json"
                if runtime_file.exists():
                    debug_file = runtime_file
                    environment = 'runtime'
                elif create_file.exists():
                    debug_file = create_file
                    environment = 'create'
                else:
                    compiler_info = self._get_compiler_info(str(debug_dir))
                    error_msg = f"No ethdebug file found for contract {contract_name_guess} in {debug_dir}"
                    if compiler_info:
                        error_msg += f" (compiler: {compiler_info})"
                    raise FileNotFoundError(error_msg)

        contract_name_from_file = debug_file.stem.replace('_ethdebug-runtime', '').replace('_ethdebug', '')

        with open(debug_file) as f:
            contract_data = json.load(f)
        
        instructions = []
        for inst_data in contract_data.get('instructions', []):
            instruction = Instruction(
                offset=inst_data['offset'],
                operation=inst_data['operation'],
                context=inst_data.get('context')
            )
            instructions.append(instruction)
        
        variable_locations = self._parse_variable_locations(contract_data)
        final_contract_name = contract_name if contract_name else contract_name_from_file
        
        self.debug_info = ETHDebugInfo(
            compilation=compilation_data['compilation'],
            contract_name=final_contract_name,
            environment=environment,
            instructions=instructions,
            sources=sources,
            variable_locations=variable_locations
        )
        
        return self.debug_info
    
    @staticmethod
    def _get_compiler_info(path: str) -> Optional[str]:
        """Try to extract compiler version from ethdebug.json or combined.json."""
        path_obj = Path(path)
        
        ethdebug_file = path_obj / "ethdebug.json"
        if ethdebug_file.exists():
            try:
                with open(ethdebug_file, 'r') as f:
                    data = json.load(f)
                    compiler = data.get("compilation", {}).get("compiler", {})
                    version = compiler.get("version")
                    if version:
                        return f"solc {version}"
            except (json.JSONDecodeError, KeyError, IOError):
                pass
        
        combined_file = path_obj / "combined.json"
        if combined_file.exists():
            try:
                with open(combined_file, 'r') as f:
                    data = json.load(f)
                    contracts = data.get("contracts", {})
                    for contract_key, contract_data in contracts.items():
                        metadata_str = contract_data.get("metadata")
                        if metadata_str:
                            try:
                                metadata = json.loads(metadata_str)
                                compiler = metadata.get("compiler", {})
                                version = compiler.get("version")
                                if version:
                                    return f"solc {version}"
                            except (json.JSONDecodeError, KeyError):
                                continue
            except (json.JSONDecodeError, KeyError, IOError):
                pass
        
        return None

    def _parse_variable_locations(self, contract_data: Dict[str, Any]) -> Dict[int, List[VariableLocation]]:
        """Parse variable location information from ETHDebug data."""
        variable_locations = {}
        
        for inst_data in contract_data.get('instructions', []):
            pc = inst_data['offset']
            context = inst_data.get('context', {})
            
            if 'variables' in context:
                var_list = []
                for var_data in context['variables']:
                    var_loc = VariableLocation(
                        name=var_data.get('name', 'unknown'),
                        type=var_data.get('type', 'unknown'),
                        location_type=var_data.get('location', {}).get('type', 'stack'),
                        offset=var_data.get('location', {}).get('offset', 0),
                        pc_range=(
                            var_data.get('scope', {}).get('start', pc),
                            var_data.get('scope', {}).get('end', pc)
                        )
                    )
                    var_list.append(var_loc)
                
                if var_list:
                    variable_locations[pc] = var_list
        
        if 'variables' in contract_data:
            for var_data in contract_data['variables']:
                pc_start = var_data.get('pc_start', 0)
                pc_end = var_data.get('pc_end', 0)
                
                var_loc = VariableLocation(
                    name=var_data.get('name', 'unknown'),
                    type=var_data.get('type', 'unknown'),
                    location_type=var_data.get('location_type', 'stack'),
                    offset=var_data.get('offset', 0),
                    pc_range=(pc_start, pc_end)
                )
                
                for pc in range(pc_start, pc_end + 1):
                    if pc not in variable_locations:
                        variable_locations[pc] = []
                    variable_locations[pc].append(var_loc)
        
        return variable_locations
    
    def load_source_file(self, source_path: str) -> List[str]:
        """Load and cache source file lines using centralized loader."""
        return source_loader.load_source_file(source_path, str(self.debug_dir) if self.debug_dir else None)
    
    def offset_to_line_col(self, source_path: str, offset: int) -> Tuple[int, int]:
        """Convert byte offset to line and column in source file."""
        lines = self.load_source_file(source_path)
        
        current_offset = 0
        for line_num, line in enumerate(lines, 1):
            line_len = len(line)
            if current_offset + line_len > offset:
                col = offset - current_offset + 1
                return (line_num, col)
            current_offset += line_len
        
        return (1, 1)
    
    def get_source_mapping(self) -> Dict[int, Tuple[str, int, int]]:
        """Get PC to source line mapping."""
        if not self.debug_info:
            return {}
        
        pc_to_source = {}
        
        for instruction in self.debug_info.instructions:
            source_info = self.debug_info.get_source_info(instruction.offset)
            if source_info:
                source_path, offset, length = source_info
                line, col = self.offset_to_line_col(source_path, offset)
                pc_to_source[instruction.offset] = (source_path, line, col)
        
        return pc_to_source
    
    def get_source_context(self, pc: int, context_lines: int = 2) -> Optional[Dict[str, Any]]:
        """Get source code context around a PC."""
        if not self.debug_info:
            return None
        
        source_info = self.debug_info.get_source_info(pc)
        if not source_info:
            return None
        
        source_path, offset, length = source_info
        lines = self.load_source_file(source_path)
        line_num, col = self.offset_to_line_col(source_path, offset)
        
        current_content = ""
        if 0 < line_num <= len(lines):
            current_content = lines[line_num - 1].rstrip()
        
        start_line = max(1, line_num - context_lines)
        end_line = min(len(lines), line_num + context_lines)
        
        context = {
            'file': source_path,
            'line': line_num,
            'column': col,
            'content': current_content,
            'context_lines': [],
            'lines': []
        }
        
        for i in range(start_line, end_line + 1):
            if i <= len(lines):
                context['context_lines'].append(lines[i-1].rstrip())
                context['lines'].append({
                    'number': i,
                    'content': lines[i-1].rstrip(),
                    'current': i == line_num
                })
        
        return context
    
    def format_instruction_debug(self, pc: int) -> str:
        """Format debug info for an instruction."""
        if not self.debug_info:
            return ""
        
        instruction = self.debug_info.get_instruction_at_pc(pc)
        if not instruction:
            return f"No debug info for PC {pc}"
        
        parts = [f"PC {pc}: {instruction.mnemonic}"]
        
        if instruction.arguments:
            parts.append(f"({', '.join(instruction.arguments)})")
        
        source_info = self.debug_info.get_source_info(pc)
        if source_info:
            source_path, offset, length = source_info
            line, col = self.offset_to_line_col(source_path, offset)
            parts.append(f"@ {os.path.basename(source_path)}:{line}:{col}")
        
        return " ".join(parts)
    
    def get_variables_debug_info(self, pc: int) -> Optional[Dict[str, Any]]:
        """Get variable information at a specific PC."""
        if not self.debug_info:
            return None
        
        variables = self.debug_info.get_variables_at_pc(pc)
        if not variables:
            return None
        
        return {
            'pc': pc,
            'variables': [
                {
                    'name': var.name,
                    'type': var.type,
                    'location': var.location_type,
                    'offset': var.offset
                }
                for var in variables
            ]
        }
    
    def format_variables_debug(self, pc: int, stack: Optional[List[int]] = None, 
                             memory: Optional[bytes] = None, 
                             storage: Optional[Dict[int, int]] = None) -> str:
        """Format variable values for debugging display."""
        var_info = self.get_variables_debug_info(pc)
        if not var_info or not var_info['variables']:
            return ""
        
        lines = ["Local Variables:"]
        for var in var_info['variables']:
            value_str = "?"
            
            if var['location'] == 'stack' and stack and var['offset'] < len(stack):
                value_str = hex(stack[var['offset']])
            elif var['location'] == 'memory' and memory:
                value_str = "<memory>"
            elif var['location'] == 'storage' and storage and var['offset'] in storage:
                value_str = hex(storage[var['offset']])
            
            lines.append(f"  - {var['name']}: {value_str} ({var['type']}) @ {var['location']}[{var['offset']}]")
        
        return "\n".join(lines)


# =============================================================================
# Multi-Contract Support
# =============================================================================

@dataclass
class ContractDebugInfo:
    """Container for contract-specific debug information."""
    address: str
    name: str
    debug_dir: Path
    ethdebug_info: Optional[ETHDebugInfo] = None
    parser: Optional[ETHDebugParser] = None
    srcmap_info: Optional[Any] = None
    srcmap_parser: Optional[Any] = None

    @property
    def has_debug_info(self) -> bool:
        """Check if contract has any debug info loaded."""
        return self.ethdebug_info is not None or self.srcmap_info is not None
    
    def get_parser(self):
        """Get the active parser (ethdebug or srcmap)."""
        return self.parser or self.srcmap_parser


@dataclass
class ExecutionContext:
    """Represents the current execution context during cross-contract calls."""
    address: str
    debug_info: Optional[ETHDebugInfo] = None
    srcmap_info: Optional[Any] = None
    pc_offset: int = 0
    call_type: str = "CALL"
    
    def __repr__(self):
        return f"ExecutionContext(address={self.address[:10]}..., call_type={self.call_type})"


class MultiContractETHDebugParser:
    """
    Enhanced ETHDebug parser that supports multiple contracts.
    
    This parser maintains a registry of contracts and their debug information,
    enabling seamless source-level debugging across contract boundaries.
    """
    
    def __init__(self):
        self.contracts: Dict[str, ContractDebugInfo] = {}
        self.contract_names: Dict[str, str] = {}
        self.execution_stack: List[ExecutionContext] = []
        self.source_cache: Dict[str, List[str]] = {}
    
    def load_contract(self, address: str, debug_dir: Union[str, Path], 
                     contract_name: Optional[str] = None) -> ContractDebugInfo:
        """
        Load debug information for a specific contract.
        Automatically detects ETHDebug (solc >= 0.8.29) or srcmap-runtime (legacy).
        """
        if not address.startswith('0x'):
            address = '0x' + address
        address = to_checksum_address(address)
        
        debug_dir = Path(debug_dir)
        if not debug_dir.exists():
            raise FileNotFoundError(f"Debug directory not found: {debug_dir}")
        
        ethdebug_file = debug_dir / "ethdebug.json"
        combined_file = debug_dir / "combined.json"
        
        ethdebug_info = None
        parser = None
        srcmap_info = None
        srcmap_parser = None
        
        if ethdebug_file.exists():
            parser = ETHDebugParser()
            parser.source_cache = self.source_cache
            parser.debug_dir = debug_dir
            ethdebug_info = parser.load_ethdebug_files(debug_dir, contract_name)
            if not contract_name:
                contract_name = ethdebug_info.contract_name
        elif combined_file.exists():
            from .source_map import SourceMapParser
            srcmap_parser = SourceMapParser()
            srcmap_info = srcmap_parser.load_combined_json(debug_dir, contract_name)
            if not contract_name:
                contract_name = srcmap_info.contract_name
        else:
            compiler_info = ETHDebugParser._get_compiler_info(str(debug_dir))
            error_msg = f"No debug info found in {debug_dir}. Expected ethdebug.json (solc >= 0.8.29) or combined.json (legacy solc)."
            if compiler_info:
                error_msg += f" (detected compiler: {compiler_info})"
            raise FileNotFoundError(error_msg)
        
        contract_info = ContractDebugInfo(
            address=address,
            name=contract_name,
            debug_dir=debug_dir,
            ethdebug_info=ethdebug_info,
            parser=parser,
            srcmap_info=srcmap_info,
            srcmap_parser=srcmap_parser
        )
        
        self.contracts[address] = contract_info
        self.contract_names[address] = contract_name
        
        return contract_info
    
    def load_from_deployment(self, deployment_file: Union[str, Path]) -> Dict[str, ContractDebugInfo]:
        """Load contract debug information from a deployment.json file."""
        deployment_file = Path(deployment_file)
        if not deployment_file.exists():
            raise FileNotFoundError(f"Deployment file not found: {deployment_file}")
        
        with open(deployment_file) as f:
            deployment_data = json.load(f)
        
        loaded_contracts = {}
        
        if 'address' in deployment_data and 'contract' in deployment_data:
            contract_name = deployment_data['contract']
            address = deployment_data['address']
            debug_dir = deployment_file.parent
            
            if deployment_data.get('ethdebug', {}).get('enabled', False):
                try:
                    contract_debug_info = self.load_contract(address, debug_dir, contract_name)
                    loaded_contracts[address] = contract_debug_info
                except Exception as e:
                    from soldb.utils.colors import warning
                    print(warning(f"Warning: Failed to load debug info for {contract_name}: {e}"))
        
        elif 'contracts' in deployment_data:
            for contract_name, contract_info in deployment_data['contracts'].items():
                if isinstance(contract_info, dict) and 'address' in contract_info:
                    address = contract_info['address']
                    base_dir = deployment_file.parent
                    debug_dirs = [
                        base_dir / f"debug_{contract_name.lower()}",
                        base_dir / "debug" / contract_name,
                        base_dir / contract_name / "debug",
                        base_dir
                    ]
                    
                    debug_dir = None
                    for candidate in debug_dirs:
                        if candidate.exists() and (candidate / "ethdebug.json").exists():
                            debug_dir = candidate
                            break
                    
                    if debug_dir:
                        try:
                            contract_debug_info = self.load_contract(address, debug_dir, contract_name)
                            loaded_contracts[address] = contract_debug_info
                        except Exception as e:
                            from soldb.utils.colors import warning
                            print(warning(f"Warning: Failed to load debug info for {contract_name}: {e}"))
        
        return loaded_contracts
    
    def load_from_mapping_file(self, mapping_file: Union[str, Path]) -> Dict[str, ContractDebugInfo]:
        """Load contracts from a mapping file."""
        mapping_file = Path(mapping_file)
        if not mapping_file.exists():
            raise FileNotFoundError(f"Mapping file not found: {mapping_file}")
        
        with open(mapping_file) as f:
            mapping_data = json.load(f)
        
        loaded_contracts = {}
        
        for contract in mapping_data.get('contracts', []):
            address = contract['address']
            name = contract.get('name', 'Unknown')
            debug_dir = Path(contract['debug_dir'])
            
            if not debug_dir.is_absolute():
                debug_dir = mapping_file.parent / debug_dir
            
            try:
                contract_debug_info = self.load_contract(address, debug_dir, name)
                loaded_contracts[address] = contract_debug_info
            except Exception as e:
                from soldb.utils.colors import warning
                print(warning(f"Warning: Failed to load contract {name} at {address}: {e}"))
        
        return loaded_contracts
    
    def get_contract_at_address(self, address: str) -> Optional[ContractDebugInfo]:
        """Get contract debug info for a given address."""
        address = to_checksum_address(address)
        return self.contracts.get(address)
    
    def push_context(self, address: str, call_type: str = "CALL", pc_offset: int = 0):
        """Push a new execution context when entering a contract."""
        contract_info = self.get_contract_at_address(address)
        if contract_info:
            context = ExecutionContext(
                address=address,
                debug_info=contract_info.ethdebug_info,
                srcmap_info=contract_info.srcmap_info,
                pc_offset=pc_offset,
                call_type=call_type
            )
            self.execution_stack.append(context)
            return context
        return None
    
    def pop_context(self) -> Optional[ExecutionContext]:
        """Pop execution context when returning from a contract."""
        if self.execution_stack:
            return self.execution_stack.pop()
        return None
    
    def get_current_context(self) -> Optional[ExecutionContext]:
        """Get the current execution context."""
        if self.execution_stack:
            return self.execution_stack[-1]
        return None
    
    def get_current_contract(self) -> Optional[ContractDebugInfo]:
        """Get the currently executing contract's debug info."""
        context = self.get_current_context()
        if context:
            return self.get_contract_at_address(context.address)
        return None
    
    def get_source_info_for_address(self, address: str, pc: int) -> Optional[Dict[str, Any]]:
        """Get source information for a specific address and PC."""
        contract_info = self.get_contract_at_address(address)
        if not contract_info:
            return None
        
        active_parser = contract_info.get_parser()
        if active_parser:
            return active_parser.get_source_context(pc)
        return None
    
    def format_call_stack(self) -> str:
        """Format the current call stack for display."""
        if not self.execution_stack:
            return "Call stack is empty"
        
        lines = ["Call Stack:"]
        lines.append("-" * 60)
        
        for i, context in enumerate(self.execution_stack):
            contract_name = self.contract_names.get(context.address, "Unknown")
            prefix = f"#{i} "
            
            contract_info = self.get_contract_at_address(context.address)
            if contract_info:
                lines.append(f"{prefix}{contract_name} [{context.call_type}]")
                lines.append(f"   at: {context.address}")
            else:
                lines.append(f"{prefix}{context.address} [{context.call_type}]")
        
        lines.append("-" * 60)
        return "\n".join(lines)
    
    def get_all_loaded_contracts(self) -> List[Tuple[str, str]]:
        """Get list of all loaded contracts (address, name) pairs."""
        return [(addr, info.name) for addr, info in self.contracts.items()]
    
    def clear(self):
        """Clear all loaded contracts and reset state."""
        self.contracts.clear()
        self.contract_names.clear()
        self.execution_stack.clear()
        self.source_cache.clear()
    
    def __repr__(self):
        contract_list = ", ".join([f"{name}@{addr[:10]}..." 
                                  for addr, name in self.contract_names.items()])
        return f"MultiContractETHDebugParser(contracts=[{contract_list}])"
